///*
//设S是一个具有n个元素的集合，S=a1，a2,..., an, 现将S划分成k个满足下列条件
//的子集S1，S2,..., Sk,且满足:
//1. Si不等于空集，
//2. Si交Sj = 空集，
//3. S1 U S2 U ... U Sk = S, 则称S1，S2，..., Sk 是S的一个划分，
//它相当于把S集合中的n个元素a1，a2,..., an放入k个无标号的盒子中，使得没有一个盒子为空。
//请你确定n个元素al，a2,...,an放入k个无标号盒子中去的划分数S(n, k).
//
//输入:
//给出n和k
//
//输出:
//n个元素al，a2,...,an放入k个无标号盒子中去的划分数S(n, k)
//
//输入示例：
//10 6
//
//输出示例：
//22827
//*/
//
//
///*
//n个元素分到k个盒子里:
//边界
//n<k||k==0  S(n,k)=0
//n==k||k==1  S(n,k)=1
//递归该关系式：
//情况1：a[i]是k个子集中的一个，则其余n- 1个元素划分到k- 1个盒子里S(n-1,k-1);
//情况2: a[i]不是k个子集中的单独一个,则其余n- 1个元素划分到k个盒子里S(n-1,k)，
//      并且a[i]与k个集合中的任意一个可以构成一个新的集合S(n-1,k)*k
//综上，S(n,k)=S(n-1,k-1)+S(n-1,k)*k
//*/
//
//#include<iostream>
//using namespace std;
//
//typedef long long ll;
//
//ll S(long n, long k)
//{
//	if (n < k || k == 0) return 0;
//	if (n == k || k == 1) return 1;
//	return S(n - 1, k - 1) + S(n - 1, k) * k;
//}
//
//int main()
//{
// long n, k;
//	cin >> n >> k;
//	cout << S(n, k) << endl;
//
//	return 0;
//}