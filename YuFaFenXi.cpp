///*
//【问题描述】
//
//“你能告诉我表示一个集合需要的语法吗？”
//
//“当然，集合可以推导出左右大括号，中间的非终结符是一个可能为空的元素列表。
//可能为空的元素列表可以推出空或列表。每个列表可以推出元素或元素逗号列表，
//每个元素可以推导出一个给定字符表的符号，也可以推导出一个集合。”
//（这个可以不用看那么仔细，后面有数学表示）
//
//“那么如果我给你一个字符串，你能告诉我它在语法上能正确表示一个集合吗？”
//
//“当然！”
//
//你给他展示了下面的语法规则，可以生成一个集合（就是前面语言描述的）
//
//Set::= "{" Elementlist "}"
//
//Elementlist::= <empty> | List
//
//List::= Element | Element "," List
//
//Element::= At om | Set
//
//Atom::= "{" | "}" | ","
//
//其中<empty>表示空串。
//
//很快他发现这个问题比他预想的难。因为字符表的符号很特殊是括号和逗号
//（对应这条规则Atom::= "{" | "}" | ","），这三个符号也出现在了集合语法规则的定义里，
//所以他说如果一个集合的元素是括号和逗号，很难快速判定。
//为了证明他不对，你需要写一个高效的程序来解决这个问题。
//
//【输入形式】
//输入只有一行，表示一个字符串，每一个字符串你的程序都要判定他是否符合集合的语法规则。
//你可以假设字符串长度在1~200之间，仅包含“{”，“,”，“}”三个字符。
//
//【输出形式】
//输出包含1行，对应一个测试用例，具体格式如下：
//如果是一个集合，则输出“Set”，否则输出“No Set”
//
//【样例输入】
//{}
//
//【样例输出】
//Set
//*/
//
////
//#include <iostream>
//#include<string>
//using namespace std;
////10个测试数据对了6个
//int main()
//{
//    string s;
//    int pre;    //记录上一个大括号（左右皆可）的下标
//    int num;  //记录两个大括号之间的逗号个数
//    //得到两个大括号的下标做如下判断：
//    //若一个下标为0，一个下标为n，则逗号个数为奇数的合法
//    //若一个下标为0，另一个下标不为n，则逗号个数为偶数的合法
//    //若一个下标不为0，另一个下标为n，则逗号个数为偶数的合法
//     //若一个下标不为0，另一个下标不为n，则逗号个数为奇数的合法
//
//    cin >> s;
//    if (s[0] != '{' || s[s.size() - 1] != '}')
//    {
//        cout << "No Set" << endl;
//        return 0;
//    }
//    if (s.size() == 2)
//    {
//        cout << "Set" << endl;
//        return 0;
//    }
//
//    pre = 0;
//    num = 0; 
//    int n = s.size();
//    for (int i = 1; i < n; ++i)
//    {
//        if (s[i] == ',')
//            num++;
//        else
//        {
//            if ((pre == 0 && i == n - 1 && num % 2 == 0) || (pre == 0 && i != n - 1 && num % 2)
//                || (pre != 0 && i == n - 1 && num % 2) || (pre != 0 && i != n - 1 && num % 2 == 0))
//            {
//                cout << "No Set" << endl;
//                return 0;
//            }
//            else
//            {
//                num = 0;
//                pre = i;
//            }
//        }
//    }
//    cout << "Set" << endl;
//
//    return 0;
//}