///*
//约19世纪末，在欧洲的商店中出售一种智力玩具，在一块铜板上有三根钢，
//最左边的钢自上而下，由小到大顺序串着64个云盘构成的塔，
//目的是将最左边杆上的盘全部移到中间杆上，条件是一次只能移动一个盘，且
//不允许大盘放在小盘子上面。
//
//这是一个著名的问题，几乎所有的教材上都有这个问题，
//由于条件是一次只能移动一个盘，且不允许大盘放在小盘上面，
//所以64个盘的移动次数是 18,466,744,073,709,551,615。
//
//这是一个天文数字，若每一微秒可能计算一次移动，那么也需要几乎100万年，
//我们只能找出问题的解决方法，并解决较小n值时的汉诺塔，
//但很难用计算机解决64层的汉诺塔。
//
//假定圆盘从小到大编号为1,2,...
//
//输入:
// 输入为一个整数（小于20），后面跟三个单字符字符串
// 整数为盘子的数目，后三个字符表示三个杆子的编号
//
//输出：
// 输出每一步移动盘子的记录，一次移动一行，
// 每次移动的记录为例如a->3->b的形式，即把编号为3的盘子从a杆移至b杆。
// 
// 输入样例：
//  2 A B C
//
// 输出样例：
//A->1->C
//A->2->B
//C->1->B
//*/
//
//#include<iostream>
//using namespace std;
//
//long n;
//char a, b, c;
//
////将n个盘子从a移到b,中间借助c
//void hanoi(const long& n, const char& a, const char& b, const char& c)
//{
//	if (n == 1)
//	{
//		cout << a << "->" << n << "->" << b << endl;
//		return;
//	}
//
//	hanoi(n - 1, a, c, b);
//	cout << a << "->" << n << "->" << b << endl;
//	hanoi(n - 1, c, b, a);
//}
//
//int main()
//{
//	cin >> n >> a >> b >> c;
//	hanoi(n, a, b, c);
//	return 0;
//}