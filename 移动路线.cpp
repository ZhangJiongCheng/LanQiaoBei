/*
X桌子上有一个m行n列的方格矩阵，将每个方格用坐标表示,横坐标从下到上依次递增，
列坐标从左到右依次递增，左下角方格的坐标为(1,1)则右上角方格的坐标为(m,n)，
小明是个调皮的孩子，一天他捉来一只蚂蚁，不小心把蚂蚁的右脚弄伤了，
于是蚂蚁只能向上或向右移动，小明把这只蚂蚁放在左下角的方格中，
蚂蚁从左下角的方格中移动到右上角的方格中，每步移动一个方格，
蚂蚁始终在方格矩阵内移动，请计算出不同的移动路线的数目。
对于一行一列的方格矩阵，蚂蚁原地移动，移动路线数为1；
对于一行两列或两行一列的方格矩阵，蚂蚁只需一次向右或向上移动，移动路线也为1；
对一个两行三列的方格矩阵（如下）：
(2,1)(2,2)(2,3)
(1,1)(1,2)(1,3)
蚂蚁共有三种移动路线:
路线1：（1,1）->(1,2)->(1,3)->(2,3)
路线2：（1,1）->(1,2)->(2,2)->(2,3)
路线3：（1,1）->(2,1)->(2,2)->(2,3)

输入:
 输入只有一行，包括两个整数m和n代表方格矩阵的行数和列数,m、n之间用空格隔开。
 
输出：
 输出只有一行为不同的移动路线的数目。
 
输入样例：
2 3
  
输出样例：
3
*/
#include<iostream>
using namespace std;

long m, n;
long long f[101][101];

int main()
{
	cin >> m >> n;
	f[1][1] = 1;
	for (long j = 2; j <= n; ++j) f[1][j] = f[1][j - 1];
	for (long i = 2; i <= m; ++i) f[i][1] = f[i - 1][1];
	for (long i = 2; i <= m; ++i)
		for (long j = 2; j <= n; ++j)
			f[i][j] = f[i - 1][j] + f[i][j - 1];
	cout << f[m][n] << endl;
	return 0;
}