/*
一个给定序列的子序列是在该序列中删去若干元素后得到的序列。
确切的说，若给定序列X=<x1,x2,...,xn>,则另一序列Z=<z1,z2,...,zk>是X的子序列是指
存在一个严格递增的下标序列<i1,i2,...,ik>，使得对于所有的j=1,2...,k有：
Xij=Zj
例如，序列Z=<B,D,C,B>是序列X=<A,B,C,B,D,A,B>的子序列，相应的递增下标序列为
<2,3,5,7>。给定两个序列x和y，当另一序列任既是x的子序列，又是y的子序列时，
称Z是序列x和y的公共子序列。例如若X=<A,B,C,B,D,A,B>和Y=<B,D,C,A,B,A>，
则序列<B,C,A>是x和y的一个公共子序列，序列<B,C,B,A>也是x和y的一个公共子序列，
而且后者是x和y的一个最长公共子序列，因为x和y没有长度大于4的公共子序列。
给定两个序列X=<x1,x2,...,xm>和Y=<y1,y2,...,yn>。要求找出xX和y的一个最长公共子序列。

输入：
共有两行，每行为一个由大写字母构成的长度不超过1000的字符串，表示序列x和y。

输出：
第一行为一个非负整数。表示所求得的最长公共子序列的长度。
若不存在公共子序列，则输出仅有一个整数零。

输入示例：
ABCBDAB
BDCABA

输出示例：
4
*/

/*
1. 状态：dp[i][j]表示X的前i个字符和Y的前j个字符的最长公共子序列
2. 转移方程： 
           if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1]+1;
		   else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
*/

//#include<iostream>
//using namespace std;
// 
//string s1, s2;
//long dp[1001][1001];
//
//int main()
//{
//	cin >> s1 >> s2;
//	long n = s1.size();
//	long m = s2.size();
//	s1 = ' ' + s1;
//	s2 = ' ' + s2;
//	for (long i = 1; i <= n; ++i)
//		for (long j = 1; j <= m; ++j)
//			if (s1[i] == s2[j]) dp[i][j] = dp[i - 1][j - 1] + 1;
//			else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
//
//	cout << dp[n][m] << endl;
//
//	return 0;
//}