///*
//有一天，怪盗基德偷走了一颗珍贵的宝石，不料却被柯南小朋友识破了伪装，
//而他的滑翔翼的动力装置也被柯南踢出的足球破坏了，不得已，怪盗基德只能操作受损的滑翔翼逃脱。
//假设城市中一共有n栋建筑排成一条线，每栋建筑的高度各不相同。
//初始时，怪盗基德可以在任何一栋建筑的顶端，他可以选择一个方向逃跑，
//但是中途不能改变方向，因为滑翔翼动力装置受损，他只能向下滑行。
//他希望尽可能多的经过不同建筑的顶部，请问它最多可以经过多少栋不同建筑的顶部？
//
//输入：
//输入数据第一行是一个整数k代表有k组测试数据，
//每组测试数据包含两行，第一行是一个整数n代表有n栋建筑，
//第二行包含n个不同的整数，每一个对应一栋建筑的高度h，按照建筑的排列顺序给出。
//
//输出：
//对于每组测试数据，输出一行包含一个整数代表怪盗基德最多可以经过的建筑数量。
//
//输入示例：
//3
//8
//300 207 155 299 298 170 158 65
//8
//65 158 170 298 299 155 207 300
//10
//2 1 3 4 5 6 7 8 9 10
//
//输出示例：
//6
//6
//9
//*/
//
//#include<iostream>
//using namespace std;
//
//long k;  //k组测试数据
//long n;   //每组测试数据有n个数
//long a[1001];
//long dp_up[1001], dp_down[1001];
//
//int main()
//{
//	cin >> k;
//	long maxx;
//	while (k--)
//	{
//		cin >> n;
//		for (long i = 1; i <= n; ++i)
//		{
//			cin >> a[i];
//			dp_up[i] = dp_down[i] = 1;
//		}
//
//		maxx = dp_up[1];
//		for (long i = 2; i <= n; ++i)
//		{
//			for (long j = 1; j < i; ++j)
//				if (a[i] > a[j]) dp_up[i] = max(dp_up[i], dp_up[j] + 1);
//			maxx = max(maxx, dp_up[i]);
//		}
//
//      maxx = max(maxx, dp_down[1]);
//		for (long i = 2; i <= n; ++i)
//		{
//			for (long j = 1; j < i; ++j)
//				if (a[i] < a[j]) dp_down[i] = max(dp_down[i], dp_down[j] + 1);
//			maxx = max(maxx, dp_down[i]);
//		}
//
//		cout << maxx << endl;
//	}//while
//
//	return 0;
//}