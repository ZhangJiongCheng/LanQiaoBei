///*
//问题描述
//话说大诗人李白, 一生好饮。幸好他从不开车。
//一天, 他提着酒显, 从家里出来, 酒显中有酒 2 斗。他边走边唱:
//无事街上走，提显去打酒。 逢店加一倍, 遇花喝一斗。
//这一路上, 他一共遇到店 N 次, 遇到花 M 次。已知最后一次遇到的是花, 他正好把酒喝光了。
//请你计算李白这一路遇到店和花的顺序, 有多少种不同的可能?
//
//注意: 显里没酒 ( 0 斗) 时遇店是合法的, 加倍后还是没酒; 但是没酒时遇 花是不合法的。
//
//输入格式
//第一行包含两个整数 N 和 M.
//
//输出格式
//输出一个整数表示答案。由于答案可能很大，输出模 1000000007 的结果.
//
//样例输入
//5 10
//
//样例输出
//14
//
//样例说明
//如果我们用 0 代表遇到花，1 代表遇到店，14 种顺序如下：
//010101101000000
//
//010110010010000
//
//011000110010000
//
//100010110010000
//
//011001000110000
//
//100011000110000
//
//100100010110000
//
//010110100000100
//
//011001001000100
//
//100011001000100
//
//100100011000100
//
//011010000010100
//
//100100100010100
//
//101000001010100
//*/
//#include <iostream>
//using namespace std;
//
//const int M = 1e9 + 7;
//const int N = 1e2 + 10;
//int n, m;
//int f[N][N][N];  //f[i][j][k]表示遇上了i家店j朵花且当前剩k斗酒的方案数
//
//int main()
//{
//    cin >> n >> m; 
//
//    f[0][0][2] = 1;
//    for (int i = 0; i <= n; ++i)
//        for (int j = 0; j <= m; ++j)
//            for (int k = 0; k <= m; ++k)
//            {
//                int& v = f[i][j][k];
//                if (i && k % 2 == 0)
//                    v = (v + f[i - 1][j][k / 2]) % M;
//                if (j)
//                    v = (v + f[i][j - 1][k + 1]) % M;
//            }
//
//    cout << f[n][m - 1][1] << endl; 
//
//    return 0;
//}