///*
//问题描述
//小明最近迷上了积木画, 有这么两种类型的积木, 分别为I 型（大小为 2 个单位面积) 和
//L 型 (大小为 3 个单位面积):
//
//同时, 小明有一块面积大小为2×N 的画布, 画布由2×N 个1×1 区域构成。
//小明需要用以上两种积木将画布拼满, 他想知道总共有多少种不同的方式? 积木可以任意旋转, 且画布的方向固定。
//
//输入格式
//输入一个整数N，表示画布大小。
//
//输出格式
//输出一个整数表示答案。由于答案可能很大，所以输出其对 1000000007 取模后的值。
//
//样例输入
//3
//
//样例输出
//5
//*/
//
///*
//2*n,即2行n列，对于每一列来说，两行九只有00,01,10,11这四个状态
//*/
//
//#include <iostream>
//using namespace std;
//
//const int N = 1e7 + 10;
//const int M = 1e9 + 7;
//int g[4][4] = { 
//    {1,1,1,1},   //表示第i列状态为00可以转移到第i+1列的所有状态
//    {0,0,1,1},  //表示第i列状态为01可以转移到第i+1列的10,11状态
//    {0,1,0,1},  //表示第i列状态为10可以转移到第i+1列的01,11状态
//    {1,0,0,0}  //表示第i列状态为11可以转移到第i+1列的00状态
//};
//int f[N][4]; //f[i][j]表示已经操作完前i-1列且第i列状态为j的方案数
//int n;
//
//int main()
//{ 
//    cin >> n;
//    f[1][0] = 1;  
//
//    for (int i = 1; i <= n; ++i)
//        for (int j = 0; j < 4; ++j)
//            for (int k = 0; k < 4; ++k)
//                f[i + 1][j] = (f[i + 1][j] + f[i][k] * g[k][j]) % M;
//
//    cout << f[n + 1][0] << endl;
//
//    return 0;
//}