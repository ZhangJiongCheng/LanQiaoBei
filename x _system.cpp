///*
//进制规定了数字在数位上逢几进一。
//
//X 进制是一种很神奇的进制，因为其每一数位的进制并不固定！例如说某种 X 进制数，
//最低数位为二进制，第二数位为十进制，第三数位为八进制，则 X 进制数 321 转换为十进制数为 65。
//现在有两个 X 进制表示的整数 A 和 B，但是其具体每一数位的进制还不确定，
//只知道 A 和 B 是同一进制规则，且每一数位最高为 N 进制，最低为二进制。
//请你算出 A − B 的结果最小可能是多少。
//
//请注意，你需要保证 A 和 B 在 X 进制下都是合法的，即每一数位上的数字要小于其进制。
//
//输入格式
//第一行一个正整数 N，含义如题面所述。
//第二行一个正整数 Ma，表示 X 进制数 A 的位数。
//第三行 Ma 个用空格分开的整数，表示 X 进制数 A 按从高位到低位顺序各个数位上
//的数字在十进制下的表示。
//第四行一个正整数 Mb，表示 X 进制数 B 的位数。
//第五行 Mb 个用空格分开的整数，表示 X 进制数 B 按从高位到低位顺序各个数位上
//的数字在十进制下的表示。
//
//请注意，输入中的所有数字都是十进制的。
//
//输出格式
//输出一行一个整数，表示 X 进制数 A − B 的结果的最小可能值
//转换为十进制后再模 1000000007 的结果。
//
//样例输入
//11
//3
//10 4 0
//3
//1 2 0
//
//样例输出
//94
//
//提示
//当进制为：最低位 2 进制，第二数位 5 进制，第三数位 11 进制时，减法得到的差最小。
//此时 A 在十进制下是 108，B 在十进制下是 14，差值是 94。
//*/
//
//#include<iostream>
//#include<algorithm>
//using namespace std;
// 
//const int M = 1e9 + 7;
//const int N = 1e5 + 10;
//int n, ma, mb;
//int a[N], b[N];
//
//int main()
//{
//	cin >> n;
//	cin >> ma;
//	for (int i = ma - 1; i >= 0; --i)
//		cin >> a[i];
//	cin >> mb;
//	for (int i = mb - 1; i >= 0; --i)
//		cin >> b[i];
//
//	int m = max(ma, mb);
//	int res = 0;
//	for (int i = m - 1; i >= 0; --i)
//		res = (res * max({ 2,a[i] + 1,b[i] + 1 }) + a[i] - b[i]) % M;   //秦九韶算法
//
//	cout << (res + M) % M << endl;
//
//	return 0;
//}