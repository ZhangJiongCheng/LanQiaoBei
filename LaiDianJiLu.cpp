///*
//【问题描述】
//
//有一部手机记录了一些来电信息。每条信息包含日期（月和日）、时间（小时和分钟）以及号码。
//能记录的来电数量是有限的。
//
//你发现这个限制数量很快就要达到了，因此准备删除一些来电记录。
//在选择删除记录的时候你需要考虑下面两个限制：
//	1. 有一些重要的来电记录你要保留。
//	2. 你想让留下来的这些记录能够恢复来电的年份（注意，这是手机没有记录的）。恢复的方法在下面描述。
//
//计算出在满足上述限制的条件下，最少需要保留的来电记录数量。
//
//年份恢复方法：
//给定一系列的来电时间戳（内容包含月、日、小时、分钟），你按照如下方式推导年份。
//	1）最后一个来电是今年的。
//	2）通过比较最后来电和前一个来电的时间戳t和t’，如果t’<t,你假设两个电话是同一年的，反之是前一年的。
//	3）不断向前回溯得到所有电话的年份。
//
//这个方法并不一定对，但你可以假设输入中来电记录的年份按照这个规则恢复是正确的，
//并且经过删除之后的日志文件能够恢复的结果要和输入一致。
//
//提示：
//因为一个手机软件错误，没有一个来电记录的日期是2月29。
//
//【输入形式】
//输入包含1组用例。每个测试用例第一行包含一个整数n (1 ≤ n ≤ 1000)。
//接下来的n行，每行有一条来电记录。
//每条来电记录的格式为mm:dd:HH:MM number ±。它表示：
//mm月dd日HH时MM分来电，号码是number(1-16位)，+表示必须保存的电话（对应前述限制条件1），-表示其他的来电。
//
//【输出形式】
//对每个测试用例，输出最小数字，表示需要保存的最少来电记录数量。保存的来电需要满足前面的两条限制条件。
//
//【样例输入】
//7
//12:31:23:59 0123456789012345 +
//07:21:19:00 1337 -
//01:01:00:00 0987654321 -
//07:21:14:00 1337 -
//11:11:11:11 11111111111 +
//01:01:00:00 0123456789 +
//01:01:00:00 0987654321 -
//
//【样例输出】
//6
//*/
//
////结果就是在留下来的记录中，如果前一条的时间小于后一条的时间，则两条记录是同一年的，
////否则，前一条的时间是后一条的前一年
//#include <iostream>
//#include<vector>
//#include<string>
//using namespace std; 
//
//int n;
//vector<string> record;
//int ans;
//
////10个测试数据过了9个
//int main()
//{
//	cin >> n;
//	cin.ignore();   //忽略输入n之后的回车
//	for (int i = 1; i <= n; ++i)
//	{
//		string s;
//		getline(cin, s);
//		record.push_back(s);
//	}
//
//	int index = 0;  
//	for (int i = 0; i < n; ++i)  //从前往后找第一个必须保留的
//	{
//		if (record[i].back() == '+')
//		{
//			index = i;
//			break;
//		}
//	}
//
//	ans = 2;  //最后一条必须保留,还有index对应的必须保留的
//	string time = record[n - 1].substr(0, 11);
//	for (int i = n - 2; i > index; --i)
//	{
//		if (record[i].back() == '+')
//		{
//			++ans;
//			time = record[i].substr(0, 11);
//		}
//		else  //第i条不是重要信息
//		{
//			//如果i==0,直接删除（因为第i条做生意要保留是为了能正确恢复第i-1条的年份，而当i为0时，已经没有第i-1条了）
//
//			string t1 = record[i].substr(0, 11);
//			string t2 = record[i - 1].substr(0, 11);
//			if ((t1 < time && t1 < t2 && t2 < time) || (t1 > time && t1 < t2)
//				|| (t1 > time && t1 > t2 && t2 < time))
//			{
//				++ans;
//				time = t1;
//			}
//			//如果第i条的时间小于第i+1条的 且 第i条的时间大于第i-1条的，则第i条可以删除
//			//如果第i条(t1)的时间小于第i+1(time)条的 且 第i条(t1)的时间小于第i-1(t2)条 且 第i-1条(t2)的时间小于第i+1(time)条的，则第i条必须保留
//			//如果第i条的时间小于第i+1条的 且 第i条的时间小于第i-1条 且 第i-1条的时间大于第i+1条的，则第i条可以删除
//
//			//如果第i条(t1)的时间大于第i+1(time)条的 且 第i条(t1)的时间小于第i-1(t2)条，则第i条必须保留
//			//如果第i条(t1)的时间大于第i+1(time)条的 且 第i条(t1)的时间大于第i-1(t2)条 且 第i-1条(t2)的时间小于第i+1(time)条的，则第i条必须保留
//			//如果第i条的时间大于第i+1条的 且 第i条的时间大于第i-1条 且 第i-1条的时间大于第i+1条的，则第i条可以删除
//
//		}
//	}
//	cout << ans << endl;
//
//	return 0;
//}