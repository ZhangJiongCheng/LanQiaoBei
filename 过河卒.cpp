///*
//棋盘上a点有一个过河卒，需要走到目标b点,卒行走的规则可以向下或者向右，
//同时在棋盘上的某一点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为
//对方马的控制点，卒不能通过对方马的控制点。棋盘用坐标表示，a点(0,0),
//b点(n,m).同样马的位置坐标是需要给出的，现在要求你计算出
//卒从a点能够到达b点的路径的条数。
//
//输入：
// 给出n，m和对方马的坐标(a,b)
//
//输出：
// 从a点能够到达b点的路径的条数
//
//输入样例：
//8 6 0 4
//
//输出样例:
//1617
//*/
//
//#include<iostream>
//using namespace std;
//
//long n, m, a, b;
//long long f[21][21];  
//bool vis[21][21];
////马的方向数组
//long dx[] = { 1,1,-1,-1,2,2,-2,-2 };
//long dy[] = { 2,-2,2,-2,1,-1,1,-1 };
//
//int main()
//{
//	cin >> n >> m >> a >> b;
//	vis[a][b] = 1;
//	long x, y;
//	for (long i = 0; i < 8; ++i)
//	{
//		x = a + dx[i];
//		y = b + dy[i];
//		if (x >= 0 && x <= n && y >= 0 && y <= m)
//			vis[x][y] = 1;
//	}
//
//	f[0][0] = 1;
//	if (vis[0][0]) f[0][0] = 0;
//	for (long j = 1; j <= m; ++j)
//	{
//		f[0][j] = f[0][j - 1];
//		if (vis[0][j]) f[0][j] = 0;
//	}
//	for (long i = 1; i <= n; ++i)
//	{
//		f[i][0] = f[i - 1][0];
//		if (vis[i][0]) f[i][0] = 0;
//	}
//	for (long i = 1; i <= n; ++i)
//	{
//		for (long j = 1; j <= m; ++j)
//		{
//			f[i][j] = f[i - 1][j] + f[i][j - 1];
//			if (vis[i][j]) f[i][j] = 0;
//		}
//	}
//	cout << f[n][m] << endl;
//
//	return 0;
//}