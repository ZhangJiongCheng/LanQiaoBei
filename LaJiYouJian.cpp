///*
//【问题描述】
//
//为了避免垃圾邮件被检测出来，垃圾邮件发送者会修改邮件的内容来阻碍检测。
//对任意纯文本字符串s（只包含大写字母），令f(s)表示按照指定替换规则替换获得的新字符串。
//新字符串称为垃圾字符串，替换规则称为“垃圾字母表”，如下图所示。
//
//(图片文件无法在这里显示)
//
//因此，任意的纯文本字符串都唯一对应一个垃圾字符串f(s)，但是反之则不然，
//一个垃圾字符串可能对应多个纯文本字符串。
//
//给定一个纯文本字符串s，你的任务是找到所有经过替换后结果是f(s)的纯文本字符串的数量。
//
//提示：
//在下方测试用例中，纯文本字符串“BU”对应的垃圾字符串是“|3|_|”。
//一共有6个纯文本字符串经过垃圾字母表映射后会得到这个垃圾字符串，
//分别是“BU”, “IEU”, “BIJ”, “IEIJ”, “BLI”, 和 “IELI”。
//
//【输入形式】
//输入文件包含1个测试用例，每个测试用例包含1行，包含一个纯文本字符串s，
//s的长度为1-100，仅包含大写字母。
//
//【输出形式】
//输出一行，该行包括一个整数，含义如前所述。保证答案不超过10^9。
//
//【样例输入】
//BU
//
//【样例输出】
//6
//*/
//
//#include <iostream>
//#include<string>
//using namespace std;
//
//const int N = 410;
//int f[N];  //f[i]表示（垃圾字符串中）以i结尾的子串对应的纯文本字符串的数量
////垃圾字符串为S[1...n],若其中某个子串S[i...n]与映射表中的某个映射对应，则S[1...n]可以从S[1...i-1]转移过来
////状态转移方程为f[n]+=f[i-1];
//string s;
//string str[26];
//
//void init()
//{
//    str[0] = "4";
//    str[1] = "|3";
//    str[2] = "(";
//    str[3] = "|)";
//    str[4] = "3";
//    str[5] = "|=";
//    str[6] = "6";
//    str[7] = "#";
//    str[8] = "|";
//    str[9] = "_|";
//    str[10] = "|<";
//    str[11] = "|_";
//    str[12] = "|\\/|";
//    str[13] = "|\\|";
//    str[14] = "0";
//    str[15] = "|0";
//    str[16] = "(,)";
//    str[17] = "|?";
//    str[18] = "5";
//    str[19] = "7";
//    str[20] = "|_|";
//    str[21] = "\\/";
//    str[22] = "\\/\\/";
//    str[23] = "><";
//    str[24] = "-/";
//    str[25] = "2";
//}
//
//int main()
//{
//    init();
//
//    cin >> s;
//
//    //先转换成垃圾字符串
//    string laji = " ";
//    for (int i = 0; i < s.size(); ++i)  
//        laji.append(str[s[i] - 'A']);
//
//    f[0] = 1;
//    for (int i = 1; i < laji.size(); ++i)  
//    {
//        string tem;
//        for (int j = i; j >= 1; --j)
//        {
//            tem = laji[j] + tem;   //tem对应S[i...n]
//            for (int k = 0; k < 26; ++k)
//            {
//                if (str[k] == tem)
//                {
//                    f[i] += f[i - tem.size()];
//                    break;
//                }
//            }
//        }
//    }
//    cout << f[laji.size() - 1] << endl;
//
//    return 0;
//}